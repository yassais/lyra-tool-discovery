# 5 Agent Prompts for Parallel Development

Here are 5 comprehensive prompts for Claude Opus 4.5 agents to run simultaneously. Each agent has a distinct responsibility with clear boundaries.

---

## Agent 1: Homepage Redesign & Layout

```markdown
# Agent 1: Homepage Redesign & Layout

## Your Role
You are responsible for redesigning the llms-forge homepage layout. You will ONLY modify files in `/workspaces/lyra-tool-discovery/llms-forge/src/` related to the homepage layout.

## Files You Own
- `src/app/page.tsx` (main page)
- `src/components/Hero.tsx`
- `src/components/UrlInput.tsx`

## DO NOT TOUCH (other agents handle these)
- ExtractionProcess.tsx
- OutputSection.tsx
- Any new pages
- Any API routes
- lib/ folder

## Requirements

### 1. Reorganize Hero Section
The hero should now have this order from top to bottom:
1. Badge: "Free & Open Source" (move UP, closer to header)
2. Main headline: "Extract Documentation for AI Agents"
3. Subheadline: "Enter any URL to get started" (short, punchy)
4. The URL Input component (PROMINENT - this is the main CTA)
5. Quick try buttons: "Try: Next.js Docs | Vercel Docs | Stripe Docs | Tailwind CSS"
6. Below input, small feature pills: "Auto-detects llms.txt ‚Ä¢ Organized markdown ‚Ä¢ Agent-ready format"
7. BELOW all that (with spacing), the longer description: "Instantly fetch and organize documentation into downloadable markdown documents ready for Claude, ChatGPT, and other AI assistants."
8. Two buttons: "How It Works" (scrolls to section) and "View on GitHub"

### 2. Remove These Texts
- Remove "Looks for llms.txt" label from UrlInput
- Remove any redundant llms.txt references in hero

### 3. URL Input Changes
- Remove the "Looks for llms.txt" label above input
- Keep placeholder: "https://docs.example.com" or "Enter any website URL"
- Button text: "Extract" 
- When clicked, navigate to `/extract?url={encodedUrl}` instead of handling locally
- The quick try buttons should also navigate to /extract with the URL

### 4. Styling Requirements
- Keep the black/white monochrome theme
- Badge at top should be subtle but visible
- URL input should be the visual centerpiece
- Feature pills below input should be small, muted text
- Good spacing between sections

### 5. Implementation Details
```tsx
// Hero structure should be:
<section>
  {/* Top badge - subtle */}
  <Badge>Free & Open Source</Badge>
  
  {/* Main headline */}
  <h1>Extract Documentation for AI Agents</h1>
  
  {/* Short subhead */}
  <p>Enter any URL to get started</p>
  
  {/* URL Input - PROMINENT */}
  <UrlInput onSubmit={(url) => router.push(`/extract?url=${encodeURIComponent(url)}`)} />
  
  {/* Quick try links */}
  <div>Try: <button>Next.js</button> | <button>Vercel</button> | ...</div>
  
  {/* Feature pills */}
  <div>Auto-detects llms.txt ‚Ä¢ Organized markdown ‚Ä¢ Agent-ready</div>
  
  {/* Spacing */}
  
  {/* Longer description */}
  <p>Instantly fetch and organize documentation...</p>
  
  {/* Action buttons */}
  <div>
    <button>How It Works</button>
    <button>GitHub</button>
  </div>
</section>
```

### 6. Quick Try URLs
```typescript
const QUICK_TRY = [
  { name: 'Next.js', url: 'https://nextjs.org/docs' },
  { name: 'Vercel', url: 'https://vercel.com/docs' },
  { name: 'Stripe', url: 'https://stripe.com/docs' },
  { name: 'Tailwind', url: 'https://tailwindcss.com/docs' },
];
```

## Success Criteria
- [ ] Hero reorganized with URL input as centerpiece
- [ ] "Looks for llms.txt" removed
- [ ] Free & Open Source badge moved up
- [ ] Description moved down with proper spacing
- [ ] Quick try buttons navigate to /extract?url=
- [ ] Submit navigates to /extract?url=
- [ ] Clean, balanced layout
- [ ] No TypeScript errors
```

---

## Agent 2: Ubuntu OS-Themed Extraction Page

```markdown
# Agent 2: Ubuntu OS-Themed Extraction Page

## Your Role
You are responsible for creating the standalone `/extract` page with an Ubuntu/Linux OS desktop theme. This page shows the extraction process in a visually immersive way.

## Files You Create
- `src/app/extract/page.tsx` (main extraction page)
- `src/components/os/Desktop.tsx` (Ubuntu desktop container)
- `src/components/os/Taskbar.tsx` (bottom taskbar)
- `src/components/os/Window.tsx` (draggable window component)
- `src/components/os/MusicPlayer.tsx` (small music player window)
- `src/components/os/BrowserWindow.tsx` (iframe browser window)
- `src/components/os/TerminalWindow.tsx` (main terminal window)

## DO NOT TOUCH (other agents handle these)
- Homepage components
- API routes in lib/
- Actual extraction logic (you just display states)

## Requirements

### 1. Page Structure `/extract`
- Reads `?url=` query parameter
- Full-screen Ubuntu-style desktop
- Dark purple/orange Ubuntu gradient background OR subtle dark gray
- Three windows floating on desktop
- Bottom taskbar with time, app icons

### 2. Desktop Component
```tsx
// Desktop.tsx
- Full viewport height/width
- Ubuntu-style wallpaper (can be CSS gradient or subtle pattern)
- Dark theme (matches our black/white aesthetic but with Ubuntu feel)
- Contains Window components
- Shows extraction URL at top or in terminal title
```

### 3. Taskbar Component
```tsx
// Taskbar.tsx - Bottom bar like Ubuntu/Windows
- Left: "Activities" or app menu icon
- Center: Open window icons (Terminal, Music, Browser)
- Right: System tray (wifi icon, volume icon, time: "Jan 15, 2026 3:42 PM")
- Height: ~48px
- Background: rgba(0,0,0,0.8) with blur
```

### 4. Window Component (Reusable)
```tsx
interface WindowProps {
  title: string;
  icon?: ReactNode;
  children: ReactNode;
  defaultPosition: { x: number; y: number };
  defaultSize: { width: number; height: number };
  zIndex?: number;
  minimized?: boolean;
  onClose?: () => void;
  onMinimize?: () => void;
}

// Features:
- Title bar with window controls (minimize, maximize, close circles)
- Ubuntu-style: close (red), minimize (yellow), maximize (green) on LEFT
- Draggable by title bar (use framer-motion drag)
- Window shadow and rounded corners
- Content area below title bar
```

### 5. MusicPlayer Window (Small, Corner)
```tsx
// MusicPlayer.tsx - Small 300x200 window
- Position: bottom-left corner
- Shows: Album art placeholder (gray square)
- Track: "lofi beats - coding session"
- Artist: "ChillHop Music"
- Progress bar (animated, looping)
- Play/Pause, Skip buttons (non-functional, just visual)
- Volume slider
```

### 6. BrowserWindow (Medium, Right Side)
```tsx
// BrowserWindow.tsx - 400x350 window
- Position: right side, slightly overlapped
- Title bar shows: "Bing - Search"
- Has URL bar showing: "https://bing.com"
- Content: <iframe src="https://bing.com" /> OR a static Bing-like mockup
- If iframe blocked, show mockup with Bing logo and search bar
```

### 7. TerminalWindow (Large, Center-Main Focus)
```tsx
// TerminalWindow.tsx - Main window 700x500
- Position: center of screen, front (highest z-index)
- Title: "Terminal - Extracting docs.example.com"
- Black background (#0a0a0a)
- Monospace font (JetBrains Mono or similar)
- White/green text
- Shows extraction progress (receives state via props)

// Terminal content displays:
$ llm-energy extract https://docs.example.com

[INFO] Starting extraction...
[INFO] Checking for llms.txt...
[OK] Found llms.txt at /llms.txt
[INFO] Fetching content... 

‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë 78%

[INFO] Processing 24 sections...
[OK] Section 1/24: Getting Started
[OK] Section 2/24: Installation
[OK] Section 3/24: Configuration
...

// The terminal content is driven by extraction state
// Use a typewriter effect for new lines appearing
```

### 8. Extract Page Logic
```tsx
// page.tsx
'use client'

import { useSearchParams } from 'next/navigation'
import { useState, useEffect } from 'react'
import Desktop from '@/components/os/Desktop'

export default function ExtractPage() {
  const searchParams = useSearchParams()
  const url = searchParams.get('url')
  
  const [extractionState, setExtractionState] = useState<ExtractionState>({
    status: 'idle', // 'idle' | 'checking' | 'fetching' | 'processing' | 'complete' | 'error'
    progress: 0,
    logs: [],
    result: null
  })

  useEffect(() => {
    if (url) {
      startExtraction(url)
    }
  }, [url])

  // This will call the extraction API (Agent 3 creates this)
  async function startExtraction(targetUrl: string) {
    // Update state as extraction progresses
    // Add logs to extractionState.logs array
    // Show in terminal
  }

  return (
    <Desktop>
      <MusicPlayer />
      <BrowserWindow />
      <TerminalWindow 
        url={url}
        state={extractionState}
        onComplete={(result) => {/* show download options */}}
      />
    </Desktop>
  )
}
```

### 9. Styling Details
- Use Tailwind classes
- Ubuntu-ish feel but matches our monochrome aesthetic
- Window shadows: `shadow-2xl`
- Window borders: subtle, rounded-lg
- Title bar buttons: small colored circles (8px)
- Terminal uses `font-mono` or import JetBrains Mono

### 10. After Extraction Complete
When extraction finishes, the terminal shows:
```
[SUCCESS] Extraction complete!

Generated files:
  üìÑ FULL-DOCUMENTATION.md (125 KB)
  üìÅ sections/
     ‚îú‚îÄ‚îÄ 01-getting-started.md
     ‚îú‚îÄ‚îÄ 02-installation.md
     ‚îî‚îÄ‚îÄ ... 24 files
  üìã AGENT-PROMPT.md
  ‚öôÔ∏è  mcp-config.json

[Click below to download]
```

Then show download buttons overlaid or in a new small window.

## Success Criteria
- [ ] /extract page created and accessible
- [ ] Ubuntu-style desktop with wallpaper
- [ ] Taskbar at bottom with time and icons
- [ ] Three windows: Music (small), Browser (medium), Terminal (large)
- [ ] Windows have proper title bars with colored buttons
- [ ] Terminal shows extraction progress with typewriter effect
- [ ] Clean, immersive OS experience
- [ ] No TypeScript errors
```

---

## Agent 3: Smart URL Processing & Extraction Engine

```markdown
# Agent 3: Smart URL Processing & Extraction Engine

## Your Role
You are responsible for the core extraction logic - taking ANY URL and intelligently finding/extracting documentation content. This is the brain of the application.

## Files You Create/Modify
- `src/lib/extractor.ts` (main extraction engine)
- `src/lib/url-analyzer.ts` (URL analysis and detection)
- `src/lib/html-to-markdown.ts` (HTML scraping fallback)
- `src/lib/sitemap-parser.ts` (sitemap.xml parsing)
- `src/app/api/extract/route.ts` (extraction API endpoint)

## DO NOT TOUCH (other agents handle these)
- UI components
- Page layouts
- Output generation (Agent 4)

## Requirements

### 1. URL Analysis Strategy
When a user enters ANY URL, follow this priority order:

```typescript
// url-analyzer.ts
export async function analyzeUrl(inputUrl: string): Promise<UrlAnalysis> {
  const analysis: UrlAnalysis = {
    originalUrl: inputUrl,
    baseUrl: new URL(inputUrl).origin,
    strategy: 'unknown',
    llmsTxtUrl: null,
    sitemapUrl: null,
    docsUrl: null,
    pages: []
  };

  // 1. Check for llms.txt at common locations
  const llmsTxtLocations = [
    `${analysis.baseUrl}/llms.txt`,
    `${analysis.baseUrl}/llms-full.txt`,
    `${analysis.baseUrl}/.well-known/llms.txt`,
  ];
  
  for (const url of llmsTxtLocations) {
    if (await urlExists(url)) {
      analysis.llmsTxtUrl = url;
      analysis.strategy = 'llms-txt';
      return analysis;
    }
  }

  // 2. Check for sitemap.xml
  const sitemapLocations = [
    `${analysis.baseUrl}/sitemap.xml`,
    `${analysis.baseUrl}/sitemap_index.xml`,
  ];
  
  for (const url of sitemapLocations) {
    if (await urlExists(url)) {
      analysis.sitemapUrl = url;
      // Parse sitemap for docs pages
      analysis.pages = await parseSitemap(url);
      analysis.strategy = 'sitemap';
      return analysis;
    }
  }

  // 3. Check for /docs subdomain or path
  const docsVariants = [
    `https://docs.${new URL(inputUrl).hostname.replace('www.', '')}`,
    `${analysis.baseUrl}/docs`,
    `${analysis.baseUrl}/documentation`,
  ];
  
  for (const url of docsVariants) {
    if (await urlExists(url)) {
      analysis.docsUrl = url;
      analysis.strategy = 'docs-discovery';
      return analysis;
    }
  }

  // 4. Fallback: Direct HTML scraping of the input URL
  analysis.strategy = 'html-scrape';
  analysis.pages = [inputUrl];
  return analysis;
}
```

### 2. Sitemap Parser
```typescript
// sitemap-parser.ts
export async function parseSitemap(sitemapUrl: string): Promise<string[]> {
  const response = await fetch(sitemapUrl);
  const xml = await response.text();
  
  // Parse XML to extract URLs
  // Filter for likely documentation pages:
  // - Contains /docs/, /guide/, /api/, /reference/, /tutorial/
  // - Exclude: /blog/, /changelog/, /news/, /pricing/
  
  const urls: string[] = [];
  // Use regex or DOMParser to extract <loc> tags
  const locMatches = xml.matchAll(/<loc>([^<]+)<\/loc>/g);
  
  for (const match of locMatches) {
    const url = match[1];
    if (isDocumentationUrl(url)) {
      urls.push(url);
    }
  }
  
  return urls.slice(0, 100); // Limit to prevent abuse
}

function isDocumentationUrl(url: string): boolean {
  const docPatterns = ['/docs', '/guide', '/api', '/reference', '/tutorial', '/learn', '/manual'];
  const excludePatterns = ['/blog', '/changelog', '/news', '/pricing', '/careers', '/about'];
  
  const lower = url.toLowerCase();
  const isDoc = docPatterns.some(p => lower.includes(p));
  const isExcluded = excludePatterns.some(p => lower.includes(p));
  
  return isDoc && !isExcluded;
}
```

### 3. HTML to Markdown Converter
```typescript
// html-to-markdown.ts
export async function scrapePageToMarkdown(url: string): Promise<MarkdownDocument> {
  const response = await fetch(url);
  const html = await response.text();
  
  // Extract main content
  // Priority selectors for content:
  const contentSelectors = [
    'article',
    'main',
    '[role="main"]',
    '.content',
    '.documentation',
    '.docs-content',
    '#content',
    '#main-content',
  ];
  
  // Extract title
  // 1. <title> tag
  // 2. <h1> tag
  // 3. og:title meta
  
  // Remove unwanted elements:
  // - <script>, <style>, <nav>, <footer>, <header>
  // - .sidebar, .navigation, .ads, .cookie-banner
  
  // Convert HTML to Markdown:
  // - <h1-h6> ‚Üí # to ######
  // - <p> ‚Üí paragraph with blank lines
  // - <a href="x">text</a> ‚Üí [text](x)
  // - <code> ‚Üí `code`
  // - <pre><code> ‚Üí ```code block```
  // - <ul>/<ol> ‚Üí - / 1.
  // - <img src="x" alt="y"> ‚Üí ![y](x)
  // - <table> ‚Üí markdown table
  // - <strong>/<b> ‚Üí **bold**
  // - <em>/<i> ‚Üí *italic*
  
  return {
    title: extractedTitle,
    url: url,
    content: markdownContent,
    wordCount: countWords(markdownContent),
  };
}
```

### 4. Main Extractor Engine
```typescript
// extractor.ts
export interface ExtractionOptions {
  url: string;
  onProgress?: (progress: ExtractionProgress) => void;
}

export interface ExtractionProgress {
  status: 'analyzing' | 'fetching' | 'processing' | 'complete' | 'error';
  message: string;
  progress: number; // 0-100
  currentStep?: string;
  totalSteps?: number;
  completedSteps?: number;
}

export interface ExtractionResult {
  success: boolean;
  strategy: string;
  source: {
    url: string;
    title: string;
  };
  documents: MarkdownDocument[];
  fullDocument: string;
  agentPrompt: string;
  mcpConfig: object;
  stats: {
    totalDocuments: number;
    totalWords: number;
    totalCharacters: number;
    extractionTime: number;
  };
}

export async function extract(options: ExtractionOptions): Promise<ExtractionResult> {
  const { url, onProgress } = options;
  const startTime = Date.now();

  // Step 1: Analyze URL
  onProgress?.({ status: 'analyzing', message: 'Analyzing URL...', progress: 5 });
  const analysis = await analyzeUrl(url);
  
  onProgress?.({ 
    status: 'analyzing', 
    message: `Strategy: ${analysis.strategy}`, 
    progress: 10 
  });

  let documents: MarkdownDocument[] = [];

  // Step 2: Extract based on strategy
  switch (analysis.strategy) {
    case 'llms-txt':
      onProgress?.({ status: 'fetching', message: 'Fetching llms.txt...', progress: 20 });
      documents = await extractFromLlmsTxt(analysis.llmsTxtUrl!);
      break;
      
    case 'sitemap':
      onProgress?.({ status: 'fetching', message: `Found ${analysis.pages.length} pages in sitemap`, progress: 20 });
      documents = await extractFromPages(analysis.pages, onProgress);
      break;
      
    case 'docs-discovery':
      onProgress?.({ status: 'fetching', message: 'Discovered docs location', progress: 20 });
      // Re-analyze the docs URL
      const docsAnalysis = await analyzeUrl(analysis.docsUrl!);
      // Recursive call or handle
      break;
      
    case 'html-scrape':
      onProgress?.({ status: 'fetching', message: 'Scraping page content...', progress: 20 });
      const doc = await scrapePageToMarkdown(url);
      documents = [doc];
      break;
  }

  // Step 3: Process and organize
  onProgress?.({ status: 'processing', message: 'Organizing content...', progress: 80 });
  
  // Generate outputs (Agent 4 provides these functions)
  const fullDocument = generateFullDocument(documents);
  const agentPrompt = generateAgentPrompt(documents, url);
  const mcpConfig = generateMcpConfig(url);

  onProgress?.({ status: 'complete', message: 'Extraction complete!', progress: 100 });

  return {
    success: true,
    strategy: analysis.strategy,
    source: { url, title: documents[0]?.title || url },
    documents,
    fullDocument,
    agentPrompt,
    mcpConfig,
    stats: {
      totalDocuments: documents.length,
      totalWords: documents.reduce((sum, d) => sum + d.wordCount, 0),
      totalCharacters: fullDocument.length,
      extractionTime: Date.now() - startTime,
    },
  };
}
```

### 5. llms.txt Parser
```typescript
// In extractor.ts
async function extractFromLlmsTxt(url: string): Promise<MarkdownDocument[]> {
  const response = await fetch(url);
  const content = await response.text();
  
  // llms.txt format is already markdown-ish
  // Split by ## headers into sections
  const sections = content.split(/^## /m);
  
  return sections.map((section, index) => {
    const lines = section.trim().split('\n');
    const title = lines[0] || `Section ${index + 1}`;
    const content = lines.slice(1).join('\n').trim();
    
    return {
      title,
      url,
      content: `## ${title}\n\n${content}`,
      wordCount: countWords(content),
    };
  }).filter(doc => doc.content.length > 50);
}
```

### 6. API Endpoint
```typescript
// app/api/extract/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { extract } from '@/lib/extractor';

export async function POST(request: NextRequest) {
  try {
    const { url } = await request.json();
    
    if (!url) {
      return NextResponse.json({ error: 'URL is required' }, { status: 400 });
    }

    const result = await extract({ url });
    return NextResponse.json(result);
    
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Extraction failed' },
      { status: 500 }
    );
  }
}

// Streaming endpoint for progress updates
export async function GET(request: NextRequest) {
  const url = request.nextUrl.searchParams.get('url');
  
  if (!url) {
    return NextResponse.json({ error: 'URL is required' }, { status: 400 });
  }

  // Return Server-Sent Events for progress
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      await extract({
        url,
        onProgress: (progress) => {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(progress)}\n\n`)
          );
        },
      });
      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

## Success Criteria
- [ ] URL analyzer detects best extraction strategy
- [ ] llms.txt detection and parsing works
- [ ] Sitemap parsing finds documentation pages
- [ ] Docs subdomain/path discovery works
- [ ] HTML to Markdown conversion is clean
- [ ] API endpoint handles POST requests
- [ ] Streaming progress updates work
- [ ] Handles edge cases gracefully
- [ ] No TypeScript errors
```

---

## Agent 4: Output Generation & Download System

```markdown
# Agent 4: Output Generation & Download System

## Your Role
You are responsible for generating all output files and the download system. This includes the full document, individual MDs, ZIP bundle, agent prompt, and MCP config.

## Files You Create
- `src/lib/output-generator.ts` (generates all output formats)
- `src/lib/prompt-generator.ts` (creates agent prompts)
- `src/lib/mcp-generator.ts` (creates MCP configurations)
- `src/lib/zip-builder.ts` (creates ZIP bundles)
- `src/components/DownloadPanel.tsx` (download UI component)

## DO NOT TOUCH (other agents handle these)
- Extraction logic (Agent 3)
- OS-themed UI (Agent 2)
- Homepage (Agent 1)

## Requirements

### 1. Output Generator
```typescript
// output-generator.ts
import type { MarkdownDocument, ExtractionResult } from './extractor';

export interface GeneratedOutputs {
  fullDocument: {
    filename: string;
    content: string;
    size: number;
  };
  sections: Array<{
    filename: string;
    content: string;
    size: number;
  }>;
  agentPrompt: {
    filename: string;
    content: string;
    size: number;
  };
  mcpConfig: {
    filename: string;
    content: string;
    size: number;
  };
  readme: {
    filename: string;
    content: string;
    size: number;
  };
}

export function generateOutputs(
  documents: MarkdownDocument[],
  sourceUrl: string,
  siteName: string
): GeneratedOutputs {
  
  // 1. Full Document - All content in one file
  const fullContent = generateFullDocument(documents, sourceUrl, siteName);
  
  // 2. Individual Sections
  const sections = documents.map((doc, index) => ({
    filename: `${String(index + 1).padStart(2, '0')}-${slugify(doc.title)}.md`,
    content: formatSection(doc),
    size: new Blob([formatSection(doc)]).size,
  }));
  
  // 3. Agent Prompt
  const agentPrompt = generateAgentPrompt(documents, sourceUrl, siteName);
  
  // 4. MCP Config
  const mcpConfig = generateMcpConfig(sourceUrl, siteName);
  
  // 5. README
  const readme = generateReadme(documents, sourceUrl, siteName);
  
  return {
    fullDocument: {
      filename: 'FULL-DOCUMENTATION.md',
      content: fullContent,
      size: new Blob([fullContent]).size,
    },
    sections,
    agentPrompt: {
      filename: 'AGENT-PROMPT.md',
      content: agentPrompt,
      size: new Blob([agentPrompt]).size,
    },
    mcpConfig: {
      filename: 'mcp-config.json',
      content: mcpConfig,
      size: new Blob([mcpConfig]).size,
    },
    readme: {
      filename: 'README.md',
      content: readme,
      size: new Blob([readme]).size,
    },
  };
}

function generateFullDocument(
  documents: MarkdownDocument[],
  sourceUrl: string,
  siteName: string
): string {
  const header = `# ${siteName} Documentation

> Extracted from ${sourceUrl}
> Generated on ${new Date().toISOString().split('T')[0]}
> Total sections: ${documents.length}

---

## Table of Contents

${documents.map((doc, i) => `${i + 1}. [${doc.title}](#${slugify(doc.title)})`).join('\n')}

---

`;

  const body = documents.map(doc => `
## ${doc.title}

${doc.content}

---
`).join('\n');

  return header + body;
}

function formatSection(doc: MarkdownDocument): string {
  return `# ${doc.title}

> Source: ${doc.url}

${doc.content}
`;
}
```

### 2. Prompt Generator
```typescript
// prompt-generator.ts
export function generateAgentPrompt(
  documents: MarkdownDocument[],
  sourceUrl: string,
  siteName: string
): string {
  const topics = documents.map(d => d.title).slice(0, 20);
  
  return `# Agent Instructions for ${siteName}

## Context
You have access to the complete documentation for ${siteName}, extracted from ${sourceUrl}.

## Documentation Overview
This documentation contains ${documents.length} sections covering:
${topics.map(t => `- ${t}`).join('\n')}

## How to Use This Documentation

### Finding Information
1. Use the Table of Contents in FULL-DOCUMENTATION.md to locate topics
2. Individual section files are in the /sections folder
3. Search for specific keywords within files

### When Asked Questions About ${siteName}
1. Reference the specific section that answers the question
2. Quote relevant code examples directly
3. Provide links to the original documentation when helpful

### Code Examples
When providing code examples from this documentation:
- Always show the complete, working code
- Include necessary imports
- Add comments explaining key parts

## Quick Reference

**Installation:**
\`\`\`bash
# Check the Getting Started or Installation section
\`\`\`

**Basic Usage:**
\`\`\`
# Check the Quick Start or Basic Usage section
\`\`\`

## Important Notes
- This documentation was extracted on ${new Date().toISOString().split('T')[0]}
- For the most up-to-date information, visit ${sourceUrl}
- Report any issues with this extraction to the user

---
*Generated by llm.energy*
`;
}
```

### 3. MCP Config Generator
```typescript
// mcp-generator.ts
export function generateMcpConfig(sourceUrl: string, siteName: string): string {
  const hostname = new URL(sourceUrl).hostname;
  const identifier = slugify(siteName);
  
  const config = {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "mcpServers": {
      [identifier]: {
        "description": `${siteName} documentation assistant`,
        "command": "npx",
        "args": [
          "-y",
          "@anthropic/mcp-docs-server",
          "--docs-path",
          `./${identifier}-docs/`
        ],
        "env": {
          "DOCS_SOURCE": sourceUrl
        }
      }
    },
    "quickImport": {
      "identifier": identifier,
      "manifestUrl": null,
      "customParams": {
        "description": `Documentation for ${siteName}`,
        "mcp": {
          "type": "stdio",
          "command": "npx",
          "args": ["-y", "@anthropic/mcp-docs-server", "--docs-path", `./${identifier}-docs/`]
        }
      }
    }
  };
  
  return JSON.stringify(config, null, 2);
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}
```

### 4. ZIP Builder
```typescript
// zip-builder.ts
import JSZip from 'jszip';
import type { GeneratedOutputs } from './output-generator';

export async function createZipBundle(
  outputs: GeneratedOutputs,
  siteName: string
): Promise<Blob> {
  const zip = new JSZip();
  const folderName = `${slugify(siteName)}-docs`;
  const folder = zip.folder(folderName)!;
  
  // Add README
  folder.file(outputs.readme.filename, outputs.readme.content);
  
  // Add full documentation
  folder.file(outputs.fullDocument.filename, outputs.fullDocument.content);
  
  // Add agent prompt
  folder.file(outputs.agentPrompt.filename, outputs.agentPrompt.content);
  
  // Add MCP config
  folder.file(outputs.mcpConfig.filename, outputs.mcpConfig.content);
  
  // Add sections in subfolder
  const sectionsFolder = folder.folder('sections')!;
  for (const section of outputs.sections) {
    sectionsFolder.file(section.filename, section.content);
  }
  
  return await zip.generateAsync({ type: 'blob' });
}
```

### 5. Download Panel Component
```tsx
// components/DownloadPanel.tsx
'use client';

import { useState } from 'react';
import { Download, FileText, FolderArchive, Code, Settings } from 'lucide-react';
import { createZipBundle } from '@/lib/zip-builder';
import type { GeneratedOutputs } from '@/lib/output-generator';

interface DownloadPanelProps {
  outputs: GeneratedOutputs;
  siteName: string;
}

export default function DownloadPanel({ outputs, siteName }: DownloadPanelProps) {
  const [downloading, setDownloading] = useState<string | null>(null);
  
  const downloadFile = (filename: string, content: string) => {
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };
  
  const downloadZip = async () => {
    setDownloading('zip');
    const blob = await createZipBundle(outputs, siteName);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${slugify(siteName)}-docs.zip`;
    a.click();
    URL.revokeObjectURL(url);
    setDownloading(null);
  };
  
  const formatSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };
  
  return (
    <div className="rounded-xl border border-neutral-800 bg-neutral-900/80 p-6 backdrop-blur-xl">
      <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
        <Download className="w-5 h-5" />
        Download Files
      </h3>
      
      {/* Quick Download - ZIP */}
      <button
        onClick={downloadZip}
        disabled={downloading === 'zip'}
        className="w-full mb-4 flex items-center justify-between p-4 rounded-lg bg-white text-black hover:bg-neutral-200 transition-colors"
      >
        <div className="flex items-center gap-3">
          <FolderArchive className="w-5 h-5" />
          <div className="text-left">
            <div className="font-semibold">Download All (ZIP)</div>
            <div className="text-sm opacity-70">
              {outputs.sections.length + 4} files included
            </div>
          </div>
        </div>
        <span className="text-sm opacity-70">
          {formatSize(outputs.fullDocument.size + outputs.sections.reduce((s, f) => s + f.size, 0))}
        </span>
      </button>
      
      {/* Individual Files */}
      <div className="space-y-2">
        <p className="text-sm text-neutral-400 mb-2">Or download individually:</p>
        
        {/* Full Documentation */}
        <button
          onClick={() => downloadFile(outputs.fullDocument.filename, outputs.fullDocument.content)}
          className="w-full flex items-center justify-between p-3 rounded-lg border border-neutral-800 hover:border-neutral-600 transition-colors"
        >
          <div className="flex items-center gap-3">
            <FileText className="w-4 h-4 text-neutral-400" />
            <span className="text-white">{outputs.fullDocument.filename}</span>
          </div>
          <span className="text-sm text-neutral-500">{formatSize(outputs.fullDocument.size)}</span>
        </button>
        
        {/* Agent Prompt */}
        <button
          onClick={() => downloadFile(outputs.agentPrompt.filename, outputs.agentPrompt.content)}
          className="w-full flex items-center justify-between p-3 rounded-lg border border-neutral-800 hover:border-neutral-600 transition-colors"
        >
          <div className="flex items-center gap-3">
            <Code className="w-4 h-4 text-neutral-400" />
            <span className="text-white">{outputs.agentPrompt.filename}</span>
          </div>
          <span className="text-sm text-neutral-500">{formatSize(outputs.agentPrompt.size)}</span>
        </button>
        
        {/* MCP Config */}
        <button
          onClick={() => downloadFile(outputs.mcpConfig.filename, outputs.mcpConfig.content)}
          className="w-full flex items-center justify-between p-3 rounded-lg border border-neutral-800 hover:border-neutral-600 transition-colors"
        >
          <div className="flex items-center gap-3">
            <Settings className="w-4 h-4 text-neutral-400" />
            <span className="text-white">{outputs.mcpConfig.filename}</span>
          </div>
          <span className="text-sm text-neutral-500">{formatSize(outputs.mcpConfig.size)}</span>
        </button>
        
        {/* Sections Count */}
        <div className="p-3 rounded-lg border border-neutral-800 text-neutral-400 text-sm">
          + {outputs.sections.length} section files (included in ZIP)
        </div>
      </div>
    </div>
  );
}
```

### 6. Generate README
```typescript
function generateReadme(
  documents: MarkdownDocument[],
  sourceUrl: string,
  siteName: string
): string {
  return `# ${siteName} Documentation Package

This documentation package was extracted from [${sourceUrl}](${sourceUrl}) using [llm.energy](https://llm.energy).

## Contents

- \`FULL-DOCUMENTATION.md\` - Complete documentation in a single file
- \`AGENT-PROMPT.md\` - Instructions for AI assistants (Claude, ChatGPT)
- \`mcp-config.json\` - Model Context Protocol configuration
- \`sections/\` - Individual documentation sections (${documents.length} files)

## Usage

### With Claude/ChatGPT
1. Upload \`FULL-DOCUMENTATION.md\` to your conversation
2. Optionally include \`AGENT-PROMPT.md\` for better context

### With MCP-Compatible Apps
1. Copy \`mcp-config.json\` to your MCP configuration
2. Point the docs-path to this folder

## Statistics

- **Total Sections:** ${documents.length}
- **Total Words:** ${documents.reduce((s, d) => s + d.wordCount, 0).toLocaleString()}
- **Extracted:** ${new Date().toISOString().split('T')[0]}

---

*Powered by [llm.energy](https://llm.energy) - Extract documentation for AI agents*
`;
}
```

## Success Criteria
- [ ] Full document generator combines all sections properly
- [ ] Individual section files are properly named and formatted
- [ ] Agent prompt is helpful and comprehensive
- [ ] MCP config is valid JSON with correct structure
- [ ] ZIP bundle contains all files in organized structure
- [ ] Download panel shows all options with file sizes
- [ ] Downloads work correctly for all file types
- [ ] No TypeScript errors
```

---

## Agent 5: Integration, Polish & Quality Assurance

```markdown
# Agent 5: Integration, Polish & Quality Assurance

## Your Role
You are the integration specialist. You ensure all pieces work together, handle edge cases, add loading states, error handling, and final polish. You fix any issues left by other agents.

## Files You Own/Review
- All files (review and fix integration issues)
- types.ts (shared types)
- `src/hooks/useExtraction.ts` (custom hook for extraction)
- Error boundaries and loading states
- Final styling polish

## DO NOT recreate files other agents own - only integrate and fix

## Requirements

### 1. Create Shared Types
```typescript
// src/lib/types.ts
export interface MarkdownDocument {
  title: string;
  url: string;
  content: string;
  wordCount: number;
}

export interface ExtractionProgress {
  status: 'idle' | 'analyzing' | 'fetching' | 'processing' | 'complete' | 'error';
  message: string;
  progress: number;
  currentStep?: string;
  totalSteps?: number;
  completedSteps?: number;
  logs: string[];
}

export interface ExtractionResult {
  success: boolean;
  strategy: string;
  source: {
    url: string;
    title: string;
  };
  documents: MarkdownDocument[];
  stats: {
    totalDocuments: number;
    totalWords: number;
    totalCharacters: number;
    extractionTime: number;
  };
}

export interface UrlAnalysis {
  originalUrl: string;
  baseUrl: string;
  strategy: 'llms-txt' | 'sitemap' | 'docs-discovery' | 'html-scrape';
  llmsTxtUrl: string | null;
  sitemapUrl: string | null;
  docsUrl: string | null;
  pages: string[];
}
```

### 2. Create useExtraction Hook
```typescript
// src/hooks/useExtraction.ts
'use client';

import { useState, useCallback } from 'react';
import type { ExtractionProgress, ExtractionResult } from '@/lib/types';

export function useExtraction() {
  const [progress, setProgress] = useState<ExtractionProgress>({
    status: 'idle',
    message: '',
    progress: 0,
    logs: [],
  });
  const [result, setResult] = useState<ExtractionResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  const addLog = useCallback((message: string) => {
    setProgress(prev => ({
      ...prev,
      logs: [...prev.logs, `[${new Date().toLocaleTimeString()}] ${message}`],
    }));
  }, []);

  const extract = useCallback(async (url: string) => {
    setError(null);
    setResult(null);
    setProgress({
      status: 'analyzing',
      message: 'Starting extraction...',
      progress: 0,
      logs: [],
    });

    try {
      addLog(`Starting extraction for ${url}`);
      
      // Use EventSource for streaming progress
      const eventSource = new EventSource(`/api/extract?url=${encodeURIComponent(url)}`);
      
      eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data) as ExtractionProgress;
        setProgress(prev => ({
          ...data,
          logs: [...prev.logs, data.message],
        }));
        
        if (data.status === 'complete') {
          eventSource.close();
        }
      };

      eventSource.onerror = () => {
        eventSource.close();
        // Fallback to POST request
        fetchExtraction(url);
      };

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Extraction failed');
      setProgress(prev => ({ ...prev, status: 'error', message: 'Extraction failed' }));
    }
  }, [addLog]);

  const fetchExtraction = async (url: string) => {
    try {
      const response = await fetch('/api/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url }),
      });
      
      if (!response.ok) {
        throw new Error('Extraction failed');
      }
      
      const data = await response.json();
      setResult(data);
      setProgress(prev => ({
        ...prev,
        status: 'complete',
        message: 'Extraction complete!',
        progress: 100,
      }));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Extraction failed');
      setProgress(prev => ({ ...prev, status: 'error' }));
    }
  };

  const reset = useCallback(() => {
    setProgress({ status: 'idle', message: '', progress: 0, logs: [] });
    setResult(null);
    setError(null);
  }, []);

  return { progress, result, error, extract, reset };
}
```

### 3. Ensure All Imports Work
Review all files and ensure:
- Import paths are correct (`@/lib/...` or `@/components/...`)
- All dependencies are in package.json
- No circular dependencies

### 4. Add Missing Dependencies to package.json
```json
{
  "dependencies": {
    "jszip": "^3.10.1"  // For ZIP creation
  }
}
```

Run: `pnpm add jszip` if not present

### 5. Error Boundary Component
```tsx
// src/components/ErrorBoundary.tsx
'use client';

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-8 text-center">
          <h2 className="text-xl font-bold text-red-400 mb-2">Something went wrong</h2>
          <p className="text-neutral-400">{this.state.error?.message}</p>
          <button 
            onClick={() => this.setState({ hasError: false })}
            className="mt-4 px-4 py-2 bg-white text-black rounded-lg"
          >
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 6. Loading States
Ensure all async operations show loading states:
- Homepage URL submit ‚Üí redirect with loading indicator
- Extract page ‚Üí terminal shows progress
- Downloads ‚Üí button shows spinner

### 7. Edge Case Handling
Test and fix these scenarios:
- Empty URL submitted
- Invalid URL format
- URL with no content
- Network errors
- Timeout handling (30s max)
- Very large documentation (pagination/limits)

### 8. Responsive Design Check
Ensure /extract page works on:
- Desktop (full OS experience)
- Tablet (simplified, fewer windows)
- Mobile (stack windows vertically or show terminal only)

### 9. Performance Optimization
- Add `loading.tsx` for /extract route
- Use dynamic imports for heavy components
- Ensure no memory leaks in EventSource

### 10. Final Checklist
Run through and verify:
- [ ] Homepage loads without errors
- [ ] URL input accepts any URL
- [ ] Quick try buttons navigate correctly
- [ ] /extract page renders Ubuntu desktop
- [ ] Extraction starts automatically with URL param
- [ ] Progress shows in terminal
- [ ] Downloads panel appears on completion
- [ ] All download buttons work
- [ ] ZIP contains correct file structure
- [ ] Error states show helpful messages
- [ ] No console errors
- [ ] TypeScript compiles with no errors
- [ ] Responsive on mobile/tablet

### 11. Final Build Test
```bash
cd /workspaces/lyra-tool-discovery/llms-forge
pnpm run build
```

Fix any build errors.

## Integration Points to Verify

### Homepage ‚Üí Extract Page
```tsx
// In Hero.tsx or UrlInput.tsx
const router = useRouter();
const handleSubmit = (url: string) => {
  router.push(`/extract?url=${encodeURIComponent(url)}`);
};
```

### Extract Page ‚Üí API
```tsx
// In /extract/page.tsx
const { progress, result, error, extract } = useExtraction();

useEffect(() => {
  if (url) extract(url);
}, [url, extract]);
```

### API ‚Üí Output Generator
```tsx
// In /api/extract/route.ts
import { extract } from '@/lib/extractor';
import { generateOutputs } from '@/lib/output-generator';

const result = await extract({ url });
const outputs = generateOutputs(result.documents, url, result.source.title);
```

### Terminal ‚Üí Download Panel
```tsx
// When extraction completes, show download options
{progress.status === 'complete' && result && (
  <DownloadPanel outputs={outputs} siteName={result.source.title} />
)}
```

## Success Criteria
- [ ] All pieces integrate seamlessly
- [ ] No TypeScript errors
- [ ] No runtime errors
- [ ] Responsive design works
- [ ] All edge cases handled
- [ ] Build completes successfully
- [ ] End-to-end flow works perfectly
```

---

## Running Instructions

Copy each prompt into a separate Claude conversation. All agents can run simultaneously as they work on different files:

| Agent | Focus Area | Key Files |
|-------|-----------|-----------|
| 1 | Homepage | `page.tsx`, `Hero.tsx`, `UrlInput.tsx` |
| 2 | OS UI | `/extract/page.tsx`, `components/os/*` |
| 3 | Extraction | `lib/extractor.ts`, `api/extract/route.ts` |
| 4 | Outputs | `lib/output-generator.ts`, `DownloadPanel.tsx` |
| 5 | Integration | All files, `lib/types.ts`, hooks |

Run Agent 5 **last** or have them periodically check the work of others to integrate!---

## Running Instructions

Copy each prompt into a separate Claude conversation. All agents can run simultaneously as they work on different files:

| Agent | Focus Area | Key Files |
|-------|-----------|-----------|
| 1 | Homepage | `page.tsx`, `Hero.tsx`, `UrlInput.tsx` |
| 2 | OS UI | `/extract/page.tsx`, `components/os/*` |
| 3 | Extraction | `lib/extractor.ts`, `api/extract/route.ts` |
| 4 | Outputs | `lib/output-generator.ts`, `DownloadPanel.tsx` |
| 5 | Integration | All files, `lib/types.ts`, hooks |

Run Agent 5 **last** or have them periodically check the work of others to integrate!